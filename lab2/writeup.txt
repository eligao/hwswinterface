phase_1:
  String comparerision.
  String is:
  "Science isn't about why, it's about why not?"

Phase_2:
  Loop
  6 digits (separated)
  passcode is in the form of :
  x y z x y z

Phase_3:
  Jump table (switch).
  Input 2 digits.
  Possible combinations:
    0 535
    1 926
    2 214
    3 339
    4 119
    5 352
    6 919
    7 412

Phase_4:
  input a number as i
  func4(i)=func4(i-1)+func4(i-2)
  (recursive fibonacci numbers generator)
  if func4(i)==55 then success
  answer here: i=9

Phase_5:
  Dump of assembler code for function phase_5:
=> 0x0000000000401002 <+0>:     sub    $0x18,%rsp
   0x0000000000401006 <+4>:     lea    0x8(%rsp),%rcx
   0x000000000040100b <+9>:     lea    0xc(%rsp),%rdx
   0x0000000000401010 <+14>:    mov    $0x401ebe,%esi
   0x0000000000401015 <+19>:    mov    $0x0,%eax                        # // prepare stack and sscanf call
   0x000000000040101a <+24>:    callq  0x400ab0 <__isoc99_sscanf@plt>   # read n nums as a, b
   0x000000000040101f <+29>:    cmp    $0x1,%eax                        # if n > 1 :
   0x0000000000401022 <+32>:    jg     0x401029 <phase_5+39>            #   pass
   0x0000000000401024 <+34>:    callq  0x40163d <explode_bomb>          # else : boom
   0x0000000000401029 <+39>:    mov    0xc(%rsp),%eax                   # eax = a
   0x000000000040102d <+43>:    and    $0xf,%eax                        # eax &= 0xF // clear all bits higher then 4th LSB
   0x0000000000401030 <+46>:    mov    %eax,0xc(%rsp)                   # a = eax
   0x0000000000401034 <+50>:    cmp    $0xf,%eax                        # if a == 0xF:
   0x0000000000401037 <+53>:    je     0x401065 <phase_5+99>            #   boom
   0x0000000000401039 <+55>:    mov    $0x0,%ecx                        # ecx = 0
   0x000000000040103e <+60>:    mov    $0x0,%edx                        # edx = 0
   0x0000000000401043 <+65>:    add    $0x1,%edx                        # do {  edx ++
   0x0000000000401046 <+68>:    cltq                                    #       convert_long_to_qword(eax) // arithmetically extend eax to rax, i.e. copy sign bit of eax to higher bits in rax (seems doing nothing here)
   0x0000000000401048 <+70>:    mov    0x401ba0(,%rax,4),%eax           #       eax = array[rax]    // see the following table for (int)array
   0x000000000040104f <+77>:    add    %eax,%ecx                        #       ecx += eax }
   0x0000000000401051 <+79>:    cmp    $0xf,%eax                        # while
   0x0000000000401054 <+82>:    jne    0x401043 <phase_5+65>            #    ( eax != 0xf )
   0x0000000000401056 <+84>:    mov    %eax,0xc(%rsp)                   # b = eax
   0x000000000040105a <+88>:    cmp    $0xc,%edx                        # if (edx != 0xc)
   0x000000000040105d <+91>:    jne    0x401065 <phase_5+99>            #   boom
   0x000000000040105f <+93>:    cmp    0x8(%rsp),%ecx                   # else if (ecx == b)
   0x0000000000401063 <+97>:    je     0x40106a <phase_5+104>           #   continue
   0x0000000000401065 <+99>:    callq  0x40163d <explode_bomb>          # else boom
   0x000000000040106a <+104>:   add    $0x18,%rsp                       # // restore stack
   0x000000000040106e <+108>:   retq                                    # return
End of assembler dump.

link array for eax=array[rax]
find the 0xC(12)th link before the value of 0xF (array[6])
0x401ba0 <array.3014>:         0 0x0000000a     1 0x00000002     2 0x0000000e     3 0x00000007
0x401bb0 <array.3014+16>:      4 0x00000008     5 0x0000000c     6>0x0000000f     7 0x0000000b
0x401bc0 <array.3014+32>:      8 0x00000000     9 0x00000004     a 0x00000001     b 0x0000000d
0x401bd0 <array.3014+48>:      c 0x00000003     d 0x00000009     e 0x00000006     f 0x00000005
The link list (reverse):
f<6<e<2<1<a<0<8<4<9<d<b<7<3<c<5<f
0 1 2 3 4 5 6 7 8 9 a b c d e f 0
^_______________________<
input a is the 12th link before value f. Here, a=7
input b it the sum of all values in the path of link. Here b = f+6+e+2+1+a+0+8+4+9+d+b(HEX) = 64(HEX) =93 (DEC)
therefore, the key is :
7 93

Phase_6:
Dump of assembler code for function main:
    ...
   0x0000000000400e4c <+296>:   callq  0x40165f <read_line>     # input = read_line();
   0x0000000000400e51 <+301>:   mov    %rax,%rdi                # 
   0x0000000000400e54 <+304>:   callq  0x4010d9 <phase_6>       # phase_6(input);
   0x0000000000400e59 <+309>:   callq  0x401785 <phase_defused> # phase_defused();
   0x0000000000400e5e <+314>:   mov    $0x0,%eax
   0x0000000000400e63 <+319>:   pop    %rbx
   0x0000000000400e64 <+320>:   retq                            # return 0;
End of assembler dump.

Dump of assembler code for function fun6:                       # node * fun6(node0);
   0x000000000040106f <+0>:     mov    0x8(%rdi),%r8            # sort the linked list at node0 from smaller to greater
   0x0000000000401073 <+4>:     movq   $0x0,0x8(%rdi)           # and return the new head
   0x000000000040107b <+12>:    mov    %rdi,%rax
   0x000000000040107e <+15>:    mov    %rdi,%rcx
   0x0000000000401081 <+18>:    test   %r8,%r8
   0x0000000000401084 <+21>:    jne    0x4010c6 <fun6+87>
   0x0000000000401086 <+23>:    mov    %rdi,%rax
   0x0000000000401089 <+26>:    retq
   0x000000000040108a <+27>:    mov    %rdx,%rcx
   0x000000000040108d <+30>:    mov    0x8(%rcx),%rdx
   0x0000000000401091 <+34>:    test   %rdx,%rdx
   0x0000000000401094 <+37>:    je     0x40109f <fun6+48>
   0x0000000000401096 <+39>:    cmp    %esi,(%rdx)
   0x0000000000401098 <+41>:    jg     0x40108a <fun6+27>
   0x000000000040109a <+43>:    mov    %rcx,%rdi
   0x000000000040109d <+46>:    jmp    0x4010a2 <fun6+51>
   0x000000000040109f <+48>:    mov    %rcx,%rdi
   0x00000000004010a2 <+51>:    cmp    %rdx,%rdi
   0x00000000004010a5 <+54>:    je     0x4010ad <fun6+62>
   0x00000000004010a7 <+56>:    mov    %r8,0x8(%rdi)
   0x00000000004010ab <+60>:    jmp    0x4010 b0 <fun6+65>
   0x00000000004010ad <+62>:    mov    %r8,%rax
   0x00000000004010b0 <+65>:    mov    0x8(%r8),%rcx
   0x00000000004010b4 <+69>:    mov    %rdx,0x8(%r8)
   0x00000000004010b8 <+73>:    test   %rcx,%rcx
   0x00000000004010bb <+76>:    je     0x4010d7 <fun6+104>
   0x00000000004010bd <+78>:    mov    %rcx,%r8
   0x00000000004010c0 <+81>:    mov    %rax,%rcx
   0x00000000004010c3 <+84>:    mov    %rax,%rdi
   0x00000000004010c6 <+87>:    mov    %rcx,%rdx
   0x00000000004010c9 <+90>:    test   %rcx,%rcx
   0x00000000004010cc <+93>:    je     0x4010a2 <fun6+51>
   0x00000000004010ce <+95>:    mov    (%r8),%esi
   0x00000000004010d1 <+98>:    cmp    %esi,(%rcx)
   0x00000000004010d3 <+100>:   jg     0x40108d <fun6+30>
   0x00000000004010d5 <+102>:   jmp    0x4010a2 <fun6+51>
   0x00000000004010d7 <+104>:   repz retq
End of assembler dump.

Dump of assembler code for function phase_6:                    # phase_6(input) {
=> 0x00000000004010d9 <+0>:     sub    $0x8,%rsp                    # stack-=8
   0x00000000004010dd <+4>:     mov    $0xa,%edx                    # edx = 10
   0x00000000004010e2 <+9>:     mov    $0x0,%esi                    # esi = 0
   0x00000000004010e7 <+14>:    callq  0x400b80 <strtol@plt>        # int v = strtol(input, esi, 10);
   0x00000000004010ec <+19>:    mov    %eax,0x20168e(%rip)          # node0.val = v; // 0x602780 <node0>
   0x00000000004010f2 <+25>:    mov    $0x602780,%edi               
   0x00000000004010f7 <+30>:    callq  0x40106f <fun6>              # node * p_node = func6((node*) 0x602780);
   0x00000000004010fc <+35>:    mov    0x8(%rax),%rax               # p_node = p_node.next;
   0x0000000000401100 <+39>:    mov    0x8(%rax),%rax               # p_node = p_node.next;
   0x0000000000401104 <+43>:    mov    0x8(%rax),%rax               # p_node = p_node.next;
   0x0000000000401108 <+47>:    mov    0x201672(%rip),%edx          # v = node0.val; // 0x602780 <node0> 
   0x000000000040110e <+53>:    cmp    %edx,(%rax)                  # if v != p_node->val;
   0x0000000000401110 <+55>:    je     0x401117 <phase_6+62>        #   return; 
   0x0000000000401112 <+57>:    callq  0x40163d <explode_bomb>      # else boom;
   0x0000000000401117 <+62>:    add    $0x8,%rsp
   0x000000000040111b <+66>:    retq
End of assembler dump.


struct node
{
    int val;
    int id;
    int *next;
};                          ~~~~~~~~~v this value is modified as your input  
    0x602780 <node0>:       0x00000000      0x00000000      0x00602790      0x00000000
    0x602790 <node1>:       0x00000176      0x00000001      0x006027a0      0x00000000
    0x6027a0 <node2>:       0x0000033a      0x00000002      0x006027b0      0x00000000
    0x6027b0 <node3>:       0x00000172      0x00000003      0x006027c0      0x00000000
    0x6027c0 <node4>:       0x0000030e      0x00000004      0x006027d0      0x00000000
    0x6027d0 <node5>:       0x000001e8      0x00000005      0x006027e0      0x00000000
    0x6027e0 <node6>:       0x000002a1      0x00000006      0x006027f0      0x00000000
    0x6027f0 <node7>:       0x0000011e      0x00000007      0x00602800      0x00000000
    0x602800 <node8>:       0x00000258      0x00000008      0x00602810      0x00000000
    0x602810 <node9>:       0x00000211      0x00000009      0x00000000      0x00000000

summary: 
1. read in a number v (DEC)
2. link list node0.val = v
3. sort the linked list in fun6, in a smaller to larger manner
4. get the 4th node p_node in the linked list 
5. if v == p_node.val (here, it is 600, at node8)
6. pass! 
